| 版本 | 备注 | 时间 | 创建者 |
| :--- | :--- | :--- | :--- |
| 1.0 | 文档创建 | 2018-12-17 | yaosiyu@shuidihuzhu.com |

## 接口概述

| 属性 | 规则 |
| :--- | :--- |
| 使用协议 | HTTPS |
| 数据格式 | JSON |
| 编码格式 | UTF-8 |
| 传参方式 | POST |
| Content-type | Content-Type: application/json |

## 报文格式

1. 统一格式

```json
{
	"content": "加密字符串,AES加密数据，再进行Base64编码", 
	"inscompanyId": "保险公司编号" 
}
```

2. **加密代码参见 [附录](#加密)**

3. 请求`content`

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| UUID | 唯一标识 | String | Y | 一次请求、响应使用同一个UUID |
| BizContent | 业务数据 | JSON | Y | **具体字段参见各接口详情** |
| ServiceName | 接口标识 | String | Y | [接口字典](#接口字典) |
| Timestamp | 时间戳 | Long | Y | 11位毫秒数 |

4. 响应`content`

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| UUID | 唯一标识 | String | Y | 一次请求、响应使用同一个UUID |
| Timestamp | 时间戳 | Long | Y | 11位毫秒数,可以直接使用请求的Timestamp |
| ErrorCode | 响应码 | Integer | Y | [响应码字典](#响应码字典) |
| ErrorMsg | 响应信息 | String | Y |   |
| BizContent | 业务数据 | JSON | Y | **具体字段参见各接口详情** |

> 业务是否成功依据 `ErrorCode` 和 `ErrorMsg`
> 当发生业务失败时，例如保单验真不通过，可以直接返回一个空的BizContent，即 `{}`

## 字典引用

### <span id="接口字典">接口字典</span>

| 接口名称 | 接口标识 | 发起方 | 响应方 |
| :--- | :--- | :--- | :--- |
| [保单校验接口](#保单校验接口) | iVerify | 水滴 | 第三方保险公司 |
| [理赔报案接口](#理赔报案接口) | iReport | 水滴 | 第三方保险公司 |
| [资料推送接口](#资料推送接口) | iPush | 水滴 | 第三方保险公司 |
| [资料审核接口](#资料审核接口) | iAudit | 第三方保险公司 | 水滴 |
| [案件状态同步](#案件状态同步) | iProcess | 第三方保险公司 | 水滴 |

### <span id="响应码字典">响应码字典</span>

| ErrorCode | 说明 |
| :--- | :--- |
| 1 | 成功 |
| 0 | 一般失败 |
| !=1 | 其他失败 |

### <span id="报案人和被保人关系字典">报案人和被保人关系字典</span>

| Type | 说明 |
| :--- | :--- |
| 1 | 本人 |
| 2 | 配偶 |
| 3 | 父母 |
| 4 | 子女 |
| 0 | 其他 |

### <span id="资料类型字典">资料类型字典</span>

| Type | 说明 |
| :--- | :--- |
| 1 | 身份证正面 |
| 2 | 身份证反面 |
| 3 | 门急诊病历或检查报告 |
| 4 | 出院小结 |
| 5 | 医疗费用发票 |
| 6 | 银行卡正面 |
| 7 | 伤残鉴定报告 |
| 8 | 意外事故证明 |
| 9 | 理赔申请书 |
| 10 | 住院病历或出院小结 |
| 11 | 医疗费用明细清单 |
| 12 | 诊断证明或病理报告 |
| 13 | 被保人身份证明 |
| 14 | 病史资料 |
| 15 | 发票与费用清单 |
| 16 | 职业证明 |
| 17 | 关系证明 |
| 18 | 客户身份基本信息补充单 |
| 20 | 诊断证明或检查结果 |
| 99 | 其他资料 |

### <span id="资料审核状态字典">资料审核状态字典</span>

| Status | 审核状态 |
| :--- | :--- |
| 1 | 审核通过 |
| 0 | 审核退回 |

### <span id="案件状态字典">案件状态字典</span>

| Status | 理赔案件状态 |
| :---- | :--- |
| 5 | 理赔结案 |
| 6 | 拒赔结案 |
| 99 | 理赔撤案 |
| 18 | 撤案恢复 |

## 接口详情

### <span id="保单校验接口">保单校验接口</span>

> 判断保单是否有效、是否能够进行线上报案，如果校验不通过，保险公司应返回对应的 `ErrorCode` 和 `ErrorMsg`

- 请求 `BizContent` 格式

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| policyNo | 保单号 | String | Y |   |
| insuredName | 被保险人 | String | Y |   |
| insuredCardNo | 被保险人身份证号 | String | Y |   |

- 返回 `BizContent` 格式（验真通过）

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| policyNo | 保单号 | String | Y |   |
| applierName | 投保人 | String | Y |   |
| insuredName | 被保人 | String | Y |   |
| beginTime | 保险起期 | Date | Y | `yyyy-MM-dd HH:mm:ss` |
| endTime | 保险止期 | Date | Y | `yyyy-MM-dd HH:mm:ss` |
| productName | 保险名称 | String | Y |   |
| dutyList | 责任列表 | List\&lt;String\&gt; | Y |   |
| amount | 保障金额 | Long | Y | 单位为分 |


### <span id="理赔报案接口">理赔报案接口</span>

> 水滴向保险公司传递报案必须信息，保险公司应该返回保险公司案件号或报案失败信息

- 请求 `BizContent` 格式

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| policyNo | 保单号 | String | Y |   |
| reportName | 报案人 | String | Y |   |
| reportMobile | 报案人手机号 | String | Y |   |
| insuredName | 被保人名称 | String | Y |   |
| insuredCardNo | 被保险人身份证号 | String | Y |   |
| relType | 关系 | Integer | Y | [报案人和被保人关系字典](#报案人和被保人关系字典) |
| reportTime | 报案时间 | Date | Y | `yyyy-MM-dd HH:mm:ss` |
| accdntTime | 出险时间 | Date | Y | `yyyy-MM-dd HH:mm:ss` |
| accdntAddress | 出险地点 | String | Y | 省,市,县 （中间用 , 分隔） |
| accdntAddressCode | 出险地区编码 | String | Y | 省编码,市编码,县编码 （中间用 , 分隔） |
| accdntDesc | 出险经过 | String | Y | VARCHAR(1024) |
| hospitalInfo | 医院信息 | String | Y |   |
| treatStatus | 治疗状态 | Integer | Y | 1 治疗前2 治疗中3 治疗结束 |
| exceptCost | 预估花费 | Long | Y | 单位为分 |
| needSectionPush | 是否需要推送资料 | Boolean | Y | 身故、伤残类的理赔水滴不接收用户上传资料，所以这种案件保险公司无需审核资料 |

- 返回 `BizContent` 格式（报案成功）

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| policyNo | 保单号 | String | Y |   |
| claimNo | 保险公司案件号 | String | Y |   |
| insuredName | 被保人 | String | Y |   |
| reportTime | 报案时间 | Date | Y | `yyyy-MM-dd HH:mm:ss` |

### <span id="资料推送接口">资料推送接口</span>

> 当水滴初审通过之后，会将用户的资料链接（链接7天内有效）推送给保险公司，保险公司审核资料，需要将审核结果通过 资料审核接口 回传给水滴。

- 请求 `BizContent` 格式

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| policyNo | 保单号 | String | Y |   |
| claimNo | 保险公司案件号 | String | Y |   |
| batchNo | 批次号 | Integer | Y | 上次批次,每次重传，上传批次+1 |
| sections | 资料对象 | List\&lt;Section\&gt; | Y |   |

- `Section` 对象格式

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| sectionKey | 资料主键 | String | Y | VARCHAR, 资料审核退回后，水滴替换重传的主键仍然和之前主键一样，但是资料链接会覆盖之前的 |
| sectionType | 资料类型 | Integer | Y | [资料类型字典](#资料类型字典) |
| sectionUrl | 资料链接 | String | Y | 链接有效期7天 |
| sectionName | 资料名称 | String | Y |   |

- 响应 `BizContent` 格式 `{}` 直接返回 `ErrorCode` 和 `ErrorMsg` 代表业务信息


### <span id="资料审核接口">资料审核接口</span>

> 保险公司审核之前水滴推送的资料，并将审核结果推送给水滴，如果不需要资料审核，可以跳过这一步，直接进行案件处理状态推送。
> 可以分批审核，即分批推送审核状态

- 请求 `BizContent` 格式

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| policyNo | 保单号 | String | Y |   |
| claimNo | 保险公司案件号 | String | Y |   |
| sectionAuits | 资料审核对象 | List\&lt;SectionAudit\&gt; | Y |   |
| isComplete | 是否全部审核完 | Boolean | N | 仅代表是否审核完必须审核的图片 |

- `SectionAudit` 对象格式

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| sectionKey | 资料主键 | String | Y | VARCHAR, 资料审核退回后，水滴替换重传的主键仍然和之前主键一样，但是资料链接会覆盖之前的 |
| auditResult | 审核状态 | Integer | Y | [资料审核状态字典](#资料审核状态字典) |
| auditReason | 审核原因 | String | Y |   |
| auditTime | 审核时间 | Date | Y | `yyyy-MM-dd HH:mm:ss` |

- 响应BizContent格式 `{}` 直接返回 `ErrorCode` 和 `ErrorMsg` 代表业务信息


### <span id="案件状态同步">案件状态同步</span>

> 保险公司处理了案件后，需要将案件状态同步给水滴

- 请求 `BizContent` 格式

| 字段名称 | 字段描述 | 类型 | 必传 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| policyNo | 保单号 | String | Y |   |
| claimNo | 保险公司案件号 | String | Y |   |
| status | 案件状态 | Integer | Y | [案件状态字典](#案件状态字典) |
| payAmount | 赔付金额 | Long | Y | 单位为分 |
| processTime | 处理时间 | Date | Y | `yyyy-MM-dd HH:mm:ss` |

- 响应 `BizContent` 格式 `{}` 直接返回 `ErrorCode` 和 `ErrorMsg`

## <span id="加密">附录-加密工具类</span>

### 秘钥示例
```java
public static final String AES_KEY = "水滴提供";

public static final String DT_KEY = "水滴提供";
```

### 加解密示例

```java
// 获取加密key
String seed = AesUtils.des3EncodeCBC(AES_KEY, DT_KEY);
// 加密content
String encryptedContent = AesUtils.encryptBase64(seed, rawContent);
// 解密content
String rawContent = AesUtils.decryptBase64(seed, encryptedContent);
```
### 加密工具类
```java
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.binary.Base64;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

import javax.crypto.*;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

@Slf4j
public class AesUtils {

    private final static String CHARSET = "utf-8";

    public static String encryptBase64(String seed, String content) {
        try {
            byte[] rawKey = getRawKey(seed.getBytes(CHARSET));
            byte[] result = encrypt(rawKey, content.getBytes(CHARSET));
            return Base64.encodeBase64String(result);
        } catch (Exception e) {
            log.error("AES加密base64编码出错", e);
            throw new RuntimeException(e);
        }
    }

    public static String decryptBase64(String seed, String encrypted) {
        try {
            byte[] rawKey = getRawKey(seed.getBytes(CHARSET));
            byte[] enc = Base64.decodeBase64(encrypted);
            byte[] result = decrypt(rawKey, enc);
            return new String(result, CHARSET);
        } catch (Exception e) {
            log.error("AES解密base64出错", e);
            throw new RuntimeException(e);
        }
    }

    private static byte[] getRawKey(byte[] seed) throws NoSuchAlgorithmException {
        KeyGenerator kgen = KeyGenerator.getInstance("AES");
        SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
        sr.setSeed(seed);
        // 192 and 256 bits may not be available
        kgen.init(128, sr);
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    private static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchPaddingException,
            NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
        // AES/CBC/PKCS5Padding
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws NoSuchPaddingException,
            NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
        // AES/CBC/PKCS5Padding
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    /**
     * 功能: [CBC加密]<br/>
     * 详细说明：应用于获取约定的AES加密参数<br/>
     * @param aesKey
     * @param dtKey
     * @return [加密后的参数]
     */
    public static String des3EncodeCBC(String aesKey, String dtKey) {
        byte[] keyiv = { 1, 2, 3, 4, 5, 6, 7, 8 };
        try {
            byte[] key = new BASE64Decoder().decodeBuffer(dtKey);
            byte[] data = aesKey.getBytes("UTF-8");
            byte[] str5 = des3EncodeCBC(key, keyiv, data);

            return new BASE64Encoder().encode(str5);
        } catch (Exception e) {
            log.error("加密AES参数报错：" + aesKey, e);
            throw new RuntimeException(e);
        }
    }

    private static byte[] des3EncodeCBC(byte[] key, byte[] keyiv, byte[] data) throws Exception {
        Key deskey = null;
        DESedeKeySpec spec = new DESedeKeySpec(key);
        SecretKeyFactory keyfactory = SecretKeyFactory.getInstance("desede");
        deskey = keyfactory.generateSecret(spec);
        Cipher cipher = Cipher.getInstance("desede/CBC/PKCS5Padding");
        IvParameterSpec ips = new IvParameterSpec(keyiv);
        cipher.init(1, deskey, ips);
        byte[] bOut = cipher.doFinal(data);
        return bOut;
    }

}
```



